{
    "docs": [
        {
            "location": "/",
            "text": "Hello\n\n\nI'm HVN.",
            "title": "Home"
        },
        {
            "location": "/#hello",
            "text": "I'm HVN.",
            "title": "Hello"
        },
        {
            "location": "/django/",
            "text": "Django as a library\n\n\n(Django for people come from Flask, or pure Python).\n\n\nI've tried to learn Django so many times, IIRC, from Django 1.4, and now it is 2.0\nand I still haven't got it. I just follow the main tutorial on its homepage,\nfinished it for so many times, but that does not make me understand Django\nat all. Something was wrong, and now I think I know it.\nThey way I \"tried\" Django is not the way I used Python libraries.\nFor Django, it is top-down, and for all the rest, I learn by bottom-up\napproach.\n\n\nWhat is the differences\n\n\nBy learning bottom-up, I know functions, classes that I have, what attributes\nthey have, and build things from them. Says, Flask, it is also a web-framework,\n     but it is very Python-like. A Flask view returns a Python string, that's it.\nIn Django, the tutorial throws ton of methods, class, shortcuts to you,\n   you might even cannot answer on top of your head what a view returns, and\n   constantly looking up into the document/tutorial, over and over again.\n\n\nLet's learn Django in a different way. Treat it as a library.\n\n\nRequests and Responses\n\n\nWhen an user accesses the website by using a web browser, the web browser sends\nan HTTP request to the website.\nDjango will receive that HTTP request, represents it by an \nHttpRequest\n object.\nDjango router will handle the request by a view which associates with\nthe requested URL.\n\n\nThe view (often a function, or a class with appropriate method), will be called\nwith the requests object as first argument, process it and return to the web-browser a HTTP response.\nA HTTP response contains some data:\n- A HTTP status code indicates the result status - OK, Redirected, Not Found ...\n- A text (Python string or byte in Python3) - so called \ncontent\n, which is usually HTML code, which\nwill be rendered by browser and displays beautifully.\n\n\nDjango represents a HTTP response by \nHttpResponse\n object.\n\n\nBoth HTTP request and response can be seen by \"console\" or \"network\" on\nmodern (2017+) web browsers. Most of them use Ctrl+U (View source) to view the text returned in response.\n\n\nAll HTTP Request/Response classes are in \ndjango.http\n sub-module.\n\n\nLet's create an \nHttpResponse\n objects.\n\n\nWritten used Django at version\n\n\nIn [22]: django.VERSION\nOut[22]: (1, 11, 2, 'final', 0)\n\n\n\n\nIn [19]: classes(django.http)\nOut[19]: ['BadHeaderError', 'FileResponse', 'Http404', 'HttpRequest', 'HttpResponse', 'HttpResponseBadRequest', 'HttpResponseForbidden', 'HttpResponseGone', 'HttpResponseNotAllowed', 'HttpResponseNotFound', 'HttpResponseNotModified', 'HttpResponsePermanentRedirect', 'HttpResponseRedirect', 'HttpResponseServerError', 'JsonResponse', 'QueryDict', 'RawPostDataException', 'SimpleCookie', 'StreamingHttpResponse', 'UnreadablePostError']\n\nIn [20]: response = django.http.HttpResponse('This is content')\n\nIn [21]: vars(response)\nOut[21]: {'cookies': <SimpleCookie: >, 'closed': False, '_handler_class': None, '_charset': None, '_closable_objects': [], '_container': [b'This is content'], '_reason_phrase': None, '_headers': {'content-type': ('Content-Type', 'text/html; charset=utf-8')}}\n\n\n\n\nvars\n is very useful, it prints all data attributes of given object.\n\n\nSo the response object contains some following data:\n- cookies (small string of data, used by browser/web app). Current cookie\nis empty.\n- \n_headers\n: contains raw data about HTTP headers, often contains type of response (a file? a normal text? a JSON data? which charset?)\n- \n_container\n: contains raw data (in a Python list), which will be join later\nand create response content/text. This is what content user will see.\n- some other attributes that use for other purposes.\n\n\nSo notice the attribute names which start with underscore (\n_\n), that says \"please do not change this directly\", use other methods. Because in Python, you can change almost every mutable thing.\n\n\nAll \"public\" (name not start with underscore) attributes (includes methods) of response:\n\n\nIn [42]: pub(response)\nOut[42]: ['charset', 'close', 'closed', 'content', 'cookies', 'delete_cookie', 'flush', 'get', 'getvalue', 'has_header', 'items', 'make_bytes', 'readable', 'reason_phrase', 'seekable', 'serialize', 'serialize_headers', 'set_cookie', 'set_signed_cookie', 'setdefault', 'status_code', 'streaming', 'tell', 'writable', 'write', 'writelines']\n\n\n\n\n\nIf you are familiar with Python files, these methods \nflush\n, \nwrite\n, \nwritelines\n, \ntell\n... are to make\nresponse object behave as a file.\n\n\nThose interesting methods are:\n- \nstatus_code\n: HTTP status code (int)\n- \nreason_phrase\n: corresponding reason phrase of the \nstatus_code\n (str)\n\n\nIn [43]: response.status_code, response.reason_phrase\nOut[43]: (200, 'OK')\n\n\n\n\n\n\nhas_header\n: check if a header exist\n\n\n\n\nIn [45]: response._headers\nOut[45]: {'content-type': ('Content-Type', 'text/html; charset=utf-8')}\n\nIn [46]: response.has_header('content-type')\nOut[46]: True\n\nIn [47]: response.has_header('hack')\nOut[47]: False\n\n\n\n\nManipulate cookie:\n\n\n\n\ndelete_cookie\n\n\nset_cookie\n\n\nset_signed_cookie\n\n\n\n\nLet update cookie and see:\n\n\nIn [52]: response.set_cookie('username', 'HVN')\n\nIn [53]: response.cookies\nOut[53]: <SimpleCookie: username='HVN'>\n\nIn [55]: response.set_signed_cookie('password', '123456')\n\nIn [57]: response.cookies\nOut[57]: <SimpleCookie: password='123456:1e9Rns:I6L7NFsJiOgRVfBqAGSoHmTXE3I' username='HVN'>\n\nIn [58]: response.delete_cookie('username'); response.cookies\nOut[58]: <SimpleCookie: password='123456:1e9Rns:I6L7NFsJiOgRVfBqAGSoHmTXE3I' username=''>\n\n\n\n\nSo in Django, a view must return an instance of \nHttpResponse\n or its sub-class instance.\n\n\nSome sub-class are pre-defined for using to return simple responses without content:\n\n\nIn [59]: classes(django.http.response)\nOut[59]: ['BadHeaderError', 'DisallowedRedirect', 'DjangoJSONEncoder', 'FileResponse', 'Header', 'Http404', 'HttpResponse', 'HttpResponseBadRequest', 'HttpResponseBase', 'HttpResponseForbidden', 'HttpResponseGone', 'HttpResponseNotAllowed', 'HttpResponseNotFound', 'HttpResponseNotModified', 'HttpResponsePermanentRedirect', 'HttpResponseRedirect', 'HttpResponseRedirectBase', 'HttpResponseServerError', 'JsonResponse', 'SimpleCookie', 'StreamingHttpResponse', 'map']\n\n\n\n\nNamely:\n- HttpResponseBadRequest:\n\n\nclass HttpResponseBadRequest(HttpResponse):\n    status_code = 400\n\n\n\n\n\n\nHttpResponseServerError:\n\n\n\n\nclass HttpResponseServerError(HttpResponse):\n    status_code = 500\n\n\n\n\n\n\nHttpResponseRedirect:\n\n\n\n\nclass HttpResponseRedirect(HttpResponseRedirectBase):\n    status_code = 302\n\n\n\n\nThey just simply set class data attribute \nstatus_code\n.\n\n\nSome non-trivial classes:\n- StreamingHttpResponse: only when you want to streaming many data (big file for example).\n- JsonResponse: this is so handy if you want to return a JSON response, the class sets header properly.\n\n\nclass JsonResponse(HttpResponse):\n    \"\"\"\n    An HTTP response class that consumes data to be serialized to JSON.\n\n    :param data: Data to be dumped into json. By default only ``dict`` objects\n      are allowed to be passed due to a security flaw before EcmaScript 5. See\n      the ``safe`` parameter for more information.\n    :param encoder: Should be an json encoder class. Defaults to\n      ``django.core.serializers.json.DjangoJSONEncoder``.\n    :param safe: Controls if only ``dict`` objects may be serialized. Defaults\n      to ``True``.\n    :param json_dumps_params: A dictionary of kwargs passed to json.dumps().\n    \"\"\"\n\n    def __init__(self, data, encoder=DjangoJSONEncoder, safe=True,\n                 json_dumps_params=None, **kwargs):\n        if safe and not isinstance(data, dict):\n            raise TypeError(\n                'In order to allow non-dict objects to be serialized set the '\n                'safe parameter to False.'\n            )\n        if json_dumps_params is None:\n            json_dumps_params = {}\n        kwargs.setdefault('content_type', 'application/json')\n        data = json.dumps(data, cls=encoder, **json_dumps_params)\n        super(JsonResponse, self).__init__(content=data, **kwargs)\n\n\n\n\nThe code is very simple, it set appropriate \ncontent_type\n, then json.dump your given data dict - it is a security problem that it avoids to\ndump non-dict object.\n\n\nIn [73]: jr = django.http.JsonResponse({'course': 'PyMivn'})\n\nIn [74]: vars(jr)\nOut[74]: {'cookies': <SimpleCookie: >, 'closed': False, '_handler_class': None, '_charset': None, '_closable_objects': [], '_container': [b'{\"course\": \"PyMivn\"}'], '_reason_phrase': None, '_headers': {'content-type': ('Content-Type', 'application/json')}}\n\n\n\n\nAll the details can see in\nhttps://docs.djangoproject.com/en/1.11/ref/request-response/\nand the code is surprising easy to read.\n\n\nRequest\n\n\nTBD",
            "title": "Django"
        },
        {
            "location": "/django/#django-as-a-library",
            "text": "(Django for people come from Flask, or pure Python).  I've tried to learn Django so many times, IIRC, from Django 1.4, and now it is 2.0\nand I still haven't got it. I just follow the main tutorial on its homepage,\nfinished it for so many times, but that does not make me understand Django\nat all. Something was wrong, and now I think I know it.\nThey way I \"tried\" Django is not the way I used Python libraries.\nFor Django, it is top-down, and for all the rest, I learn by bottom-up\napproach.",
            "title": "Django as a library"
        },
        {
            "location": "/django/#what-is-the-differences",
            "text": "By learning bottom-up, I know functions, classes that I have, what attributes\nthey have, and build things from them. Says, Flask, it is also a web-framework,\n     but it is very Python-like. A Flask view returns a Python string, that's it.\nIn Django, the tutorial throws ton of methods, class, shortcuts to you,\n   you might even cannot answer on top of your head what a view returns, and\n   constantly looking up into the document/tutorial, over and over again.  Let's learn Django in a different way. Treat it as a library.",
            "title": "What is the differences"
        },
        {
            "location": "/django/#requests-and-responses",
            "text": "When an user accesses the website by using a web browser, the web browser sends\nan HTTP request to the website.\nDjango will receive that HTTP request, represents it by an  HttpRequest  object.\nDjango router will handle the request by a view which associates with\nthe requested URL.  The view (often a function, or a class with appropriate method), will be called\nwith the requests object as first argument, process it and return to the web-browser a HTTP response.\nA HTTP response contains some data:\n- A HTTP status code indicates the result status - OK, Redirected, Not Found ...\n- A text (Python string or byte in Python3) - so called  content , which is usually HTML code, which\nwill be rendered by browser and displays beautifully.  Django represents a HTTP response by  HttpResponse  object.  Both HTTP request and response can be seen by \"console\" or \"network\" on\nmodern (2017+) web browsers. Most of them use Ctrl+U (View source) to view the text returned in response.  All HTTP Request/Response classes are in  django.http  sub-module.  Let's create an  HttpResponse  objects.  Written used Django at version  In [22]: django.VERSION\nOut[22]: (1, 11, 2, 'final', 0)  In [19]: classes(django.http)\nOut[19]: ['BadHeaderError', 'FileResponse', 'Http404', 'HttpRequest', 'HttpResponse', 'HttpResponseBadRequest', 'HttpResponseForbidden', 'HttpResponseGone', 'HttpResponseNotAllowed', 'HttpResponseNotFound', 'HttpResponseNotModified', 'HttpResponsePermanentRedirect', 'HttpResponseRedirect', 'HttpResponseServerError', 'JsonResponse', 'QueryDict', 'RawPostDataException', 'SimpleCookie', 'StreamingHttpResponse', 'UnreadablePostError']\n\nIn [20]: response = django.http.HttpResponse('This is content')\n\nIn [21]: vars(response)\nOut[21]: {'cookies': <SimpleCookie: >, 'closed': False, '_handler_class': None, '_charset': None, '_closable_objects': [], '_container': [b'This is content'], '_reason_phrase': None, '_headers': {'content-type': ('Content-Type', 'text/html; charset=utf-8')}}  vars  is very useful, it prints all data attributes of given object.  So the response object contains some following data:\n- cookies (small string of data, used by browser/web app). Current cookie\nis empty.\n-  _headers : contains raw data about HTTP headers, often contains type of response (a file? a normal text? a JSON data? which charset?)\n-  _container : contains raw data (in a Python list), which will be join later\nand create response content/text. This is what content user will see.\n- some other attributes that use for other purposes.  So notice the attribute names which start with underscore ( _ ), that says \"please do not change this directly\", use other methods. Because in Python, you can change almost every mutable thing.  All \"public\" (name not start with underscore) attributes (includes methods) of response:  In [42]: pub(response)\nOut[42]: ['charset', 'close', 'closed', 'content', 'cookies', 'delete_cookie', 'flush', 'get', 'getvalue', 'has_header', 'items', 'make_bytes', 'readable', 'reason_phrase', 'seekable', 'serialize', 'serialize_headers', 'set_cookie', 'set_signed_cookie', 'setdefault', 'status_code', 'streaming', 'tell', 'writable', 'write', 'writelines']  If you are familiar with Python files, these methods  flush ,  write ,  writelines ,  tell ... are to make\nresponse object behave as a file.  Those interesting methods are:\n-  status_code : HTTP status code (int)\n-  reason_phrase : corresponding reason phrase of the  status_code  (str)  In [43]: response.status_code, response.reason_phrase\nOut[43]: (200, 'OK')   has_header : check if a header exist   In [45]: response._headers\nOut[45]: {'content-type': ('Content-Type', 'text/html; charset=utf-8')}\n\nIn [46]: response.has_header('content-type')\nOut[46]: True\n\nIn [47]: response.has_header('hack')\nOut[47]: False  Manipulate cookie:   delete_cookie  set_cookie  set_signed_cookie   Let update cookie and see:  In [52]: response.set_cookie('username', 'HVN')\n\nIn [53]: response.cookies\nOut[53]: <SimpleCookie: username='HVN'>\n\nIn [55]: response.set_signed_cookie('password', '123456')\n\nIn [57]: response.cookies\nOut[57]: <SimpleCookie: password='123456:1e9Rns:I6L7NFsJiOgRVfBqAGSoHmTXE3I' username='HVN'>\n\nIn [58]: response.delete_cookie('username'); response.cookies\nOut[58]: <SimpleCookie: password='123456:1e9Rns:I6L7NFsJiOgRVfBqAGSoHmTXE3I' username=''>  So in Django, a view must return an instance of  HttpResponse  or its sub-class instance.  Some sub-class are pre-defined for using to return simple responses without content:  In [59]: classes(django.http.response)\nOut[59]: ['BadHeaderError', 'DisallowedRedirect', 'DjangoJSONEncoder', 'FileResponse', 'Header', 'Http404', 'HttpResponse', 'HttpResponseBadRequest', 'HttpResponseBase', 'HttpResponseForbidden', 'HttpResponseGone', 'HttpResponseNotAllowed', 'HttpResponseNotFound', 'HttpResponseNotModified', 'HttpResponsePermanentRedirect', 'HttpResponseRedirect', 'HttpResponseRedirectBase', 'HttpResponseServerError', 'JsonResponse', 'SimpleCookie', 'StreamingHttpResponse', 'map']  Namely:\n- HttpResponseBadRequest:  class HttpResponseBadRequest(HttpResponse):\n    status_code = 400   HttpResponseServerError:   class HttpResponseServerError(HttpResponse):\n    status_code = 500   HttpResponseRedirect:   class HttpResponseRedirect(HttpResponseRedirectBase):\n    status_code = 302  They just simply set class data attribute  status_code .  Some non-trivial classes:\n- StreamingHttpResponse: only when you want to streaming many data (big file for example).\n- JsonResponse: this is so handy if you want to return a JSON response, the class sets header properly.  class JsonResponse(HttpResponse):\n    \"\"\"\n    An HTTP response class that consumes data to be serialized to JSON.\n\n    :param data: Data to be dumped into json. By default only ``dict`` objects\n      are allowed to be passed due to a security flaw before EcmaScript 5. See\n      the ``safe`` parameter for more information.\n    :param encoder: Should be an json encoder class. Defaults to\n      ``django.core.serializers.json.DjangoJSONEncoder``.\n    :param safe: Controls if only ``dict`` objects may be serialized. Defaults\n      to ``True``.\n    :param json_dumps_params: A dictionary of kwargs passed to json.dumps().\n    \"\"\"\n\n    def __init__(self, data, encoder=DjangoJSONEncoder, safe=True,\n                 json_dumps_params=None, **kwargs):\n        if safe and not isinstance(data, dict):\n            raise TypeError(\n                'In order to allow non-dict objects to be serialized set the '\n                'safe parameter to False.'\n            )\n        if json_dumps_params is None:\n            json_dumps_params = {}\n        kwargs.setdefault('content_type', 'application/json')\n        data = json.dumps(data, cls=encoder, **json_dumps_params)\n        super(JsonResponse, self).__init__(content=data, **kwargs)  The code is very simple, it set appropriate  content_type , then json.dump your given data dict - it is a security problem that it avoids to\ndump non-dict object.  In [73]: jr = django.http.JsonResponse({'course': 'PyMivn'})\n\nIn [74]: vars(jr)\nOut[74]: {'cookies': <SimpleCookie: >, 'closed': False, '_handler_class': None, '_charset': None, '_closable_objects': [], '_container': [b'{\"course\": \"PyMivn\"}'], '_reason_phrase': None, '_headers': {'content-type': ('Content-Type', 'application/json')}}  All the details can see in\nhttps://docs.djangoproject.com/en/1.11/ref/request-response/\nand the code is surprising easy to read.",
            "title": "Requests and Responses"
        },
        {
            "location": "/django/#request",
            "text": "",
            "title": "Request"
        },
        {
            "location": "/django/#tbd",
            "text": "",
            "title": "TBD"
        },
        {
            "location": "/now/",
            "text": "What am I working on\n\n\n\n\nLearning Elixir and use it to solve \nFP-challenge\n\n\nLearning Neural Network to implement a hand-writing recognise system\n\n\nRelearn Machine Learning on \ncoursera\n\n\nMaking a site for \nlearning new words\n\n\nDesigning \ncourse for Linux Sysadmin",
            "title": "Now"
        },
        {
            "location": "/now/#what-am-i-working-on",
            "text": "Learning Elixir and use it to solve  FP-challenge  Learning Neural Network to implement a hand-writing recognise system  Relearn Machine Learning on  coursera  Making a site for  learning new words  Designing  course for Linux Sysadmin",
            "title": "What am I working on"
        }
    ]
}